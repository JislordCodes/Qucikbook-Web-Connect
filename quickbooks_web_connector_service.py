# -*- coding: utf-8 -*-
"""QuickBooks Web Connector Service

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1DizipHG9uBgD52xh24HcVALC7DtmhG8O
"""

import http.server
import xml.etree.ElementTree as ET
import uuid
import html

# --- Configuration ---
# These must match what's in the .qwc file
QBWC_USERNAME = "testuser"
QBWC_PASSWORD = "testpass"
# Keep track of active sessions (tickets)
ACTIVE_TICKETS = {}

#Array of objects.
CUSTOMERS_TO_SYNC = [
    {"id": "C1001", "name": "John Doe", "email": "john.doe@example.com", "phone": "555-1234"},
    {"id": "C1002", "name": "Jane Smith", "email": "jane.smith@example.com", "company": "Smith Co."},
    {"id": "C1003", "name": "Big Corp Ltd.", "phone": "555-9876", "company": "Big Corp"}
]

# --- QBXML Generation ---
def create_customer_add_qbxml(customer, request_id):
    """
    Converts a customer dictionary into a CustomerAddRq QBXML string.
    """
    # We must escape any XML-sensitive characters in our data
    name = html.escape(customer.get('name', ''))
    company = html.escape(customer.get('company', ''))
    email = html.escape(customer.get('email', ''))
    phone = html.escape(customer.get('phone', ''))

    # Build the QBXML request. This is a CustomerAdd request.
    # We use 'requestID' to match the request with its response later.
    qbxml = f"""
    <?xml version="1.0" encoding="utf-8"?>
    <?qbxml version="13.0"?>
    <QBXML>
        <QBXMLMsgsRq onError="stopOnError">
            <CustomerAddRq requestID="{request_id}">
                <CustomerAdd>
                    <Name>{name}</Name>
                    <CompanyName>{company}</CompanyName>
                    <Email>{email}</Email>
                    <Phone>{phone}</Phone>
                </CustomerAdd>
            </CustomerAddRq>
        </QBXMLMsgsRq>
    </QBXML>
    """
    return qbxml

# --- SOAP Service Handler --

class QBWC_SOAP_Handler(http.server.BaseHTTPRequestHandler):
    """
    Handles POST requests from the QuickBooks Web Connector.
    It manually parses the SOAP XML and routes to the correct QBWC method.
    """

    def do_POST(self):
        """Handle a POST request."""
        try:
            # Read the raw XML body from the request
            content_length = int(self.headers.get('Content-Length', 0))
            raw_body = self.rfile.read(content_length)

            # Find which SOAP method is being called
            method_name, params = self.parse_soap_request(raw_body.decode('utf-8'))

            # --- QBWC Method Router ---
            # Call the appropriate function based on the method
            if method_name == "authenticate":
                response_body = self.handle_authenticate(params)
            elif method_name == "sendRequestXML":
                response_body = self.handle_sendRequestXML(params)
            elif method_name == "receiveResponseXML":
                response_body = self.handle_receiveResponseXML(params)
            elif method_name == "closeConnection":
                response_body = self.handle_closeConnection(params)
            elif method_name == "serverVersion":
                response_body = self.handle_serverVersion()
            elif method_name == "clientVersion":
                response_body = self.handle_clientVersion(params)
            elif method_name == "connectionError":
                response_body = self.handle_connectionError(params)
            else:
                # Handle unknown methods
                raise ValueError(f"Unknown SOAP method: {method_name}")

            # Send the successful (200) response
            self.send_response(200)
            self.send_header('Content-Type', 'text/xml; charset=utf-8')
            self.end_headers()
            self.wfile.write(response_body.encode('utf-8'))

        except Exception as e:
            # Send an error (500) response
            print(f"Error handling request: {e}")
            self.send_response(500)
            self.send_header('Content-Type', 'text/plain; charset=utf-8')
            self.end_headers()
            self.wfile.write(f"Server Error: {e}".encode('utf-8'))

    # --- QBWC Method Implementations ---

    def handle_serverVersion(self):
        """Returns the server version."""
        print("QBWC: Called serverVersion")
        result_xml = "<serverVersionResult><string>1.0</string></serverVersionResult>"
        return self.wrap_soap_response("serverVersion", result_xml)

    def handle_clientVersion(self, params):
        """Receives the client version. No special response needed."""
        print(f"QBWC: Called clientVersion: {params.get('strVersion')}")
        result_xml = "<clientVersionResult><string></string></clientVersionResult>"
        return self.wrap_soap_response("clientVersion", result_xml)

    def handle_authenticate(self, params):
        """
        Authenticates the Web Connector.
        On success, returns a new session ticket (GUID).
        """
        username = params.get('strUserName')
        password = params.get('strPassword')

        print(f"QBWC: Called authenticate with user: {username}")

        if username == QBWC_USERNAME and password == QBWC_PASSWORD:
            ticket = str(uuid.uuid4()) # Generate a new session ticket

            # Store the ticket and the data to be synced
            ACTIVE_TICKETS[ticket] = {
                "sync_queue": list(CUSTOMERS_TO_SYNC), # Make a copy of the data
                "total_jobs": len(CUSTOMERS_TO_SYNC),
                "jobs_done": 0
            }

            # Response: {ticket, "continue"}
            # The second string tells QBWC to proceed. "" means no file.
            result_xml = f"""
            <authenticateResult>
                <string>{ticket}</string>
                <string></string>
            </authenticateResult>
            """
            print("QBWC: Authentication Succeeded. Ticket issued.")
        else:
            # Response: {ticket, "nvu"} (Not Valid User)
            result_xml = f"""
            <authenticateResult>
                <string></string>
                <string>nvu</string>
            </authenticateResult>
            """
            print("QBWC: Authentication FAILED.")

        return self.wrap_soap_response("authenticate", result_xml)

    def handle_sendRequestXML(self, params):
        """
        This is the main workhorse.
        QBWC asks for a job, we give it the next QBXML request.
        """
        ticket = params.get('ticket')
        session = ACTIVE_TICKETS.get(ticket)

        print("QBWC: Called sendRequestXML")

        if not session:
            result_xml = "<sendRequestXMLResult><string>INVALID_TICKET</string></sendRequestXMLResult>"
            print("QBWC: Invalid ticket.")
        elif session["sync_queue"]:
            # Get the next customer from the queue
            customer = session["sync_queue"].pop(0)
            request_id = f"cust_add_{customer['id']}"

            # Convert customer dict to QBXML
            qbxml_request = create_customer_add_qbxml(customer, request_id)

            result_xml = f"<sendRequestXMLResult><string>{html.escape(qbxml_request)}</string></sendRequestXMLResult>"
            print(f"QBWC: Sending job: Add Customer {customer['name']}")
        else:
            # No more jobs in the queue. Tell QBWC we are done.
            result_xml = "<sendRequestXMLResult><string></string></sendRequestXMLResult>"
            print("QBWC: No more jobs to send.")

        return self.wrap_soap_response("sendRequestXML", result_xml)

    def handle_receiveResponseXML(self, params):
        """
        QBWC sends us the *result* of the last job we gave it.
        We should log this and check for errors.
        """
        ticket = params.get('ticket')
        response_xml = params.get('response')
        session = ACTIVE_TICKETS.get(ticket)

        print(f"QBWC: Called receiveResponseXML")

        if not session:
            result_xml = "<receiveResponseXMLResult><int>-1</int></receiveResponseXMLResult>" # Error
            print("QBWC: Invalid ticket.")
        else:
            # In a real app, you would parse response_xml to see if the
            # CustomerAddRq was successful (statusCode="0") or failed.
            # If it failed, you could log it or add it back to the queue.

            print("----------------- RESPONSE FROM QUICKBOOKS -----------------")
            print(response_xml)
            print("------------------------------------------------------------")

            # Update our progress
            session["jobs_done"] += 1
            progress = int((session["jobs_done"] / session["total_jobs"]) * 100)

            # Return the percentage complete
            result_xml = f"<receiveResponseXMLResult><int>{progress}</int></receiveResponseXMLResult>"
            print(f"QBWC: Job received. Progress: {progress}%")

        return self.wrap_soap_response("receiveResponseXML", result_xml)

    def handle_closeConnection(self, params):
        """QBWC is done. We can clean up the session."""
        ticket = params.get('ticket')
        if ticket in ACTIVE_TICKETS:
            del ACTIVE_TICKETS[ticket]

        print("QBWC: Called closeConnection. Session closed.")
        result_xml = "<closeConnectionResult><string>OK</string></closeConnectionResult>"
        return self.wrap_soap_response("closeConnection", result_xml)

    def handle_connectionError(self, params):
        """QBWC is reporting an error. Log it."""
        ticket = params.get('ticket')
        message = params.get('message')
        print(f"QBWC: Connection Error! Ticket: {ticket}, Message: {message}")
        result_xml = "<connectionErrorResult><string>OK</string></connectionErrorResult>"
        return self.wrap_soap_response("connectionError", result_xml)

    # --- XML/SOAP Parsing Utilities ---

    def parse_soap_request(self, xml_string):
        """
        A very simple manual XML parser to find the QBWC method and params.
        We don't use a full SOAP library to honor the "no framework" request.
        """
        try:
            # Register namespaces to make XPath searching easier
            namespaces = {
                'soap': 'http://schemas.xmlsoap.org/soap/envelope/',
                'qb': 'http://developer.intuit.com/'
            }

            root = ET.fromstring(xml_string)

            # Find the method name (e.g., <authenticate> or <qb:authenticate>)
            body = root.find('soap:Body', namespaces)
            if body is None:
                raise ValueError("No <soap:Body> found")

            method_node = body[0]
            if method_node is None:
                raise ValueError("<soap:Body> is empty")

            # Get method name, cleaning off the namespace
            method_name = method_node.tag.split('}')[-1]

            # Extract parameters (e.g., <strUserName>value</strUserName>)
            params = {}
            for child in method_node:
                param_name = child.tag.split('}')[-1]
                params[param_name] = child.text

            return method_name, params
        except ET.ParseError as e:
            print(f"XML Parse Error: {e}")
            print(f"Received: {xml_string}")
            return None, None

    def wrap_soap_response(self, method_name, body_content):
        """Wraps the QBWC method response in a standard SOAP envelope."""
        return f"""<?xml version="1.0" encoding="utf-8"?>
        <soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
            <soap:Body>
                <{method_name}Response xmlns="http://developer.intuit.com/">
                    {body_content}
                </{method_name}Response>
            </soap:Body>
        </soap:Envelope>
        """

# --- Main function to run the server ---
def run_server(port=8000):
    """Starts the HTTP server."""
    server_address = ('', port)
    httpd = http.server.HTTPServer(server_address, QBWC_SOAP_Handler)
    print(f"Starting QBWC SOAP Service on http://localhost:{port}...")
    print("This service is HTTP-only. Use a tool like 'ngrok' to expose it publicly over HTTPS.")
    print("Press Ctrl+C to stop.")
    httpd.serve_forever()

if __name__ == "__main__":
    run_server()